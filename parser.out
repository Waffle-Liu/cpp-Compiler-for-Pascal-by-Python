Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    CONST
    THEN
    EQUAL
    UNTIL
    PROGRAM
    REPEAT
    MUL
    DIV
    MINUS
    DOT
    CASE
    BEGIN
    LE
    LB
    SEMI
    TO
    RB
    PLUS
    DOTDOT
    RECORD
    LT
    COLON
    PACKED
    LP
    COMMA
    ARRAY
    ASSIGN
    FUNCTION
    GT
    END
    GOTO
    FOR
    OPERATOR_NOT
    ELSE
    GE
    VAR
    RP
    KEY_WORD_NOT
    ID
    PROCEDURE
    IF
    AND
    UNEQUAL
    OF
    WHILE
    DOWNTO
    TYPE
    OR
    MOD

Grammar

Rule 0     S' -> factor
Rule 1     factor -> NUMBER

Terminals, with rules where they appear

AND                  : 
ARRAY                : 
ASSIGN               : 
BEGIN                : 
CASE                 : 
COLON                : 
COMMA                : 
CONST                : 
DIV                  : 
DO                   : 
DOT                  : 
DOTDOT               : 
DOWNTO               : 
ELSE                 : 
END                  : 
EQUAL                : 
FOR                  : 
FUNCTION             : 
GE                   : 
GOTO                 : 
GT                   : 
ID                   : 
IF                   : 
KEY_WORD_NOT         : 
LB                   : 
LE                   : 
LP                   : 
LT                   : 
MINUS                : 
MOD                  : 
MUL                  : 
NUMBER               : 1
OF                   : 
OPERATOR_NOT         : 
OR                   : 
PACKED               : 
PLUS                 : 
PROCEDURE            : 
PROGRAM              : 
RB                   : 
RECORD               : 
REPEAT               : 
RP                   : 
SEMI                 : 
THEN                 : 
TO                   : 
TYPE                 : 
UNEQUAL              : 
UNTIL                : 
VAR                  : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

factor               : 0

Parsing method: LALR

state 0

    (0) S' -> . factor
    (1) factor -> . NUMBER

    NUMBER          shift and go to state 1

    factor                         shift and go to state 2

state 1

    (1) factor -> NUMBER .

    $end            reduce using rule 1 (factor -> NUMBER .)


state 2

    (0) S' -> factor .


